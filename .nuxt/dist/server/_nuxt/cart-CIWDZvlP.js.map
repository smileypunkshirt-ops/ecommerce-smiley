{"version":3,"file":"cart-CIWDZvlP.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../assets/smileypunk_logo.png","../../../../components/AppHeader.vue","../../../../stores/cart.ts"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, queuePostFlushCb, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { getUserCaller, toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  let keyChanging = false;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (import.meta.dev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const caller = getUserCaller();\n      const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  function createInitialFetch() {\n    const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n    if (!nuxtApp._asyncData[key.value]?._init) {\n      initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n    }\n    return () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  }\n  const initialFetch = createInitialFetch();\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubKeyWatcher = watch(key, (newKey, oldKey) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        keyChanging = true;\n        const hadData = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n        const wasRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\n        const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          let initialValue;\n          if (oldKey && hadData) {\n            initialValue = nuxtApp._asyncData[oldKey].data.value;\n          } else {\n            initialValue = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n            initialFetchOptions.cachedData = initialValue;\n          }\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialValue);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        if (options.immediate || hadData || wasRunning) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions);\n        }\n        queuePostFlushCb(() => {\n          keyChanging = false;\n        });\n      }\n    }, { flush: \"sync\" });\n    const unsubParamsWatcher = options.watch ? watch(options.watch, () => {\n      if (keyChanging) {\n        return;\n      }\n      nuxtApp._asyncData[key.value]?._execute({ cause: \"watch\", dedupe: options.dedupe });\n    }) : () => {\n    };\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubKeyWatcher();\n        unsubParamsWatcher();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => {\n      if (!nuxtApp._asyncData[key.value]?._init) {\n        const initialFetch2 = createInitialFetch();\n        return initialFetch2();\n      }\n      return nuxtApp._asyncData[key.value].execute(...args2);\n    },\n    execute: (...args2) => asyncReturn.refresh(...args2),\n    clear: () => {\n      const entry = nuxtApp._asyncData[key.value];\n      if (entry?._abortController) {\n        try {\n          entry._abortController.abort(new DOMException(\"AsyncData aborted by user.\", \"AbortError\"));\n        } finally {\n          entry._abortController = void 0;\n        }\n      }\n      clearNuxtDataByKey(nuxtApp, key.value);\n    }\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : (nuxtApp2, options2) => {\n    const value = nuxtApp2.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp2.runWithContext(() => _handler(nuxtApp2, options2)));\n    nuxtApp2.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (...args) => {\n      const [_opts, newValue = void 0] = args;\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\n      }\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      if (asyncData._abortController) {\n        asyncData._abortController.abort(new DOMException(\"AsyncData request cancelled by deduplication\", \"AbortError\"));\n      }\n      asyncData._abortController = new AbortController();\n      asyncData.status.value = \"pending\";\n      const cleanupController = new AbortController();\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            const timeout = opts.timeout ?? options.timeout;\n            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], cleanupController.signal, timeout);\n            if (mergedSignal.aborted) {\n              const reason = mergedSignal.reason;\n              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? \"Aborted\"), \"AbortError\"));\n              return;\n            }\n            mergedSignal.addEventListener(\"abort\", () => {\n              const reason = mergedSignal.reason;\n              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? \"Aborted\"), \"AbortError\"));\n            }, { once: true, signal: cleanupController.signal });\n            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject);\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && result == null) {\n          const caller = getUserCaller();\n          const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\` or \\`null\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        if (asyncData._abortController?.signal.aborted) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        if (typeof DOMException !== \"undefined\" && error instanceof DOMException && error.name === \"AbortError\") {\n          asyncData.status.value = \"idle\";\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        cleanupController.abort();\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: import.meta.dev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n            asyncData.data.value = asyncDataDefaults.value;\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => asyncDataDefaults.value;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\nfunction mergeAbortSignals(signals, cleanupSignal, timeout) {\n  const list = signals.filter((s) => !!s);\n  if (typeof timeout === \"number\" && timeout >= 0) {\n    const timeoutSignal = AbortSignal.timeout?.(timeout);\n    if (timeoutSignal) {\n      list.push(timeoutSignal);\n    }\n  }\n  if (AbortSignal.any) {\n    return AbortSignal.any(list);\n  }\n  const controller = new AbortController();\n  for (const sig of list) {\n    if (sig.aborted) {\n      const reason = sig.reason ?? new DOMException(\"Aborted\", \"AbortError\");\n      try {\n        controller.abort(reason);\n      } catch {\n        controller.abort();\n      }\n      return controller.signal;\n    }\n  }\n  const onAbort = () => {\n    const abortedSignal = list.find((s) => s.aborted);\n    const reason = abortedSignal?.reason ?? new DOMException(\"Aborted\", \"AbortError\");\n    try {\n      controller.abort(reason);\n    } catch {\n      controller.abort();\n    }\n  };\n  for (const sig of list) {\n    sig.addEventListener?.(\"abort\", onAbort, { once: true, signal: cleanupSignal });\n  }\n  return controller.signal;\n}\n","export default \"__VITE_ASSET__Br$YGqrG__\"","<script setup lang=\"ts\">\nimport logoUrl from \"~/assets/smileypunk_logo.png\";\n\nconst props = withDefaults(\n  defineProps<{\n    itemCount?: number;\n    cartLabel?: string;\n    cartLink?: string | null;\n    centered?: boolean;\n  }>(),\n  {\n    cartLabel: \"Carrito\",\n    cartLink: \"/cart\",\n    centered: false\n  }\n);\n\nconst showCart = computed(() => !props.centered && typeof props.itemCount === \"number\");\n</script>\n\n<template>\n  <header class=\"topbar app-header\" :class=\"{ 'is-centered': centered }\">\n    <NuxtLink class=\"brand\" to=\"/\">\n      <img class=\"brand-logo\" :src=\"logoUrl\" alt=\"Smiley Punk\" />\n    </NuxtLink>\n    <NuxtLink v-if=\"showCart && cartLink\" class=\"cart-pill\" :to=\"cartLink\">\n      <span>{{ cartLabel }}</span>\n      <strong>{{ itemCount }}</strong>\n    </NuxtLink>\n    <div v-else-if=\"showCart\" class=\"cart-pill\">\n      <span>{{ cartLabel }}</span>\n      <strong>{{ itemCount }}</strong>\n    </div>\n  </header>\n</template>\n","import { defineStore } from \"pinia\";\nimport { useCartToast } from \"~/composables/useCartToast\";\n\ntype CartPayload = Record<string, unknown> & {\n  items?: unknown[];\n  cart_items?: unknown[];\n  item_count?: number;\n  cart_key?: string;\n  cartKey?: string;\n};\n\ninterface CartState {\n  cart: CartPayload | null;\n  items: unknown[];\n  itemCount: number;\n  cartKey: string | null;\n  loading: boolean;\n  error: string | null;\n}\n\nconst CART_KEY_STORAGE = \"smiley_cart_key\";\n\nconst readCartKey = () => {\n  if (!process.client) return null;\n  try {\n    return window.localStorage.getItem(CART_KEY_STORAGE);\n  } catch {\n    return null;\n  }\n};\n\nconst writeCartKey = (key: string | null) => {\n  if (!process.client) return;\n  try {\n    if (key) {\n      window.localStorage.setItem(CART_KEY_STORAGE, key);\n    } else {\n      window.localStorage.removeItem(CART_KEY_STORAGE);\n    }\n  } catch {\n    // Ignore storage errors to keep cart functional.\n  }\n};\n\nconst resolveItems = (payload: CartPayload | null) => {\n  if (!payload) return [];\n  const raw = payload.items || payload.cart_items;\n  if (!raw) return [];\n  if (Array.isArray(raw)) return raw as unknown[];\n  if (typeof raw === \"object\") {\n    return Object.entries(raw as Record<string, unknown>).map(([key, value]) => {\n      if (value && typeof value === \"object\") {\n        return { key, ...(value as Record<string, unknown>) };\n      }\n      return { key, value };\n    });\n  }\n  return [];\n};\n\nconst getTotalQuantity = (items: unknown[]) => {\n  if (!items.length) return 0;\n  return items.reduce((total, item) => {\n    if (!item || typeof item !== \"object\") return total + 1;\n    const raw = (item as Record<string, unknown>).quantity ?? (item as Record<string, unknown>).qty ?? 1;\n    const parsed = Number(raw);\n    return total + (Number.isFinite(parsed) && parsed > 0 ? parsed : 1);\n  }, 0);\n};\n\nconst isCartResponse = (payload: CartPayload | null) => {\n  if (!payload) return false;\n  return (\n    \"items\" in payload ||\n    \"cart_items\" in payload ||\n    \"item_count\" in payload ||\n    \"totals\" in payload\n  );\n};\n\nexport const useCartStore = defineStore(\"cart\", {\n  state: (): CartState => ({\n    cart: null,\n    items: [],\n    itemCount: 0,\n    cartKey: null,\n    loading: false,\n    error: null\n  }),\n  actions: {\n    async fetchCart() {\n      return await this.requestCart(\"/cart\", \"GET\");\n    },\n    async addItem(\n      productId: number,\n      quantity = 1,\n      variationId?: number,\n      variation?: Record<string, unknown>\n    ) {\n      const data = await this.requestCart(\"/cart/add-item\", \"POST\", {\n        id: productId,\n        product_id: productId,\n        quantity,\n        variation_id: variationId,\n        variation,\n        return_cart: true\n      });\n      if (!isCartResponse(data)) {\n        await this.fetchCart();\n      }\n      if (data && process.client) {\n        const { open } = useCartToast();\n        open();\n      }\n      return data;\n    },\n    async updateItem(key: string, quantity: number) {\n      const firstAttempt = await this.requestCart(`/cart/item/${encodeURIComponent(key)}`, \"POST\", {\n        quantity,\n        return_cart: true\n      });\n      if (firstAttempt) {\n        if (!isCartResponse(firstAttempt)) {\n          await this.fetchCart();\n        }\n        return firstAttempt;\n      }\n\n      const fallback = await this.requestCart(\"/cart/item\", \"POST\", {\n        key,\n        item_key: key,\n        cart_item_key: key,\n        quantity,\n        return_cart: true\n      });\n      if (!isCartResponse(fallback)) {\n        await this.fetchCart();\n      }\n      return fallback;\n    },\n    async removeItem(key: string) {\n      const data = await this.requestCart(`/cart/item/${encodeURIComponent(key)}`, \"DELETE\");\n      if (!isCartResponse(data)) {\n        await this.fetchCart();\n      }\n      return data;\n    },\n    async requestCart(path: string, method: \"GET\" | \"POST\" | \"DELETE\", body?: Record<string, unknown>) {\n      this.loading = true;\n      this.error = null;\n\n      const config = useRuntimeConfig();\n      const base = config.public.apiBase;\n\n      try {\n        if (!this.cartKey) {\n          this.cartKey = readCartKey();\n        }\n\n        const url = new URL(`${base}/wp-json/cocart/v2${path}`);\n        if (this.cartKey) {\n          url.searchParams.set(\"cart_key\", this.cartKey);\n        }\n\n        const mergedBody =\n          method === \"GET\"\n            ? undefined\n            : {\n                ...(body || {}),\n                ...(this.cartKey && !(\"cart_key\" in (body || {})) ? { cart_key: this.cartKey } : {})\n              };\n\n        const payload =\n          mergedBody && method !== \"GET\"\n            ? new URLSearchParams(\n                Object.entries(mergedBody).reduce<Record<string, string>>((acc, [key, value]) => {\n                  if (value === undefined || value === null) return acc;\n                  acc[key] = String(value);\n                  return acc;\n                }, {})\n              )\n            : undefined;\n\n        const data = await $fetch<CartPayload>(url.toString(), {\n          method,\n          body: payload,\n          credentials: \"include\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\"\n          }\n        });\n\n        if (isCartResponse(data)) {\n          this.cart = data;\n          this.items = resolveItems(data);\n          const totalQuantity = getTotalQuantity(this.items);\n          const itemCountRaw = Number(data.item_count);\n          this.itemCount = totalQuantity || (Number.isFinite(itemCountRaw) ? itemCountRaw : this.items.length);\n        }\n        const responseKey =\n          typeof data.cart_key === \"string\"\n            ? data.cart_key\n            : typeof data.cartKey === \"string\"\n              ? data.cartKey\n              : null;\n        if (responseKey) {\n          this.cartKey = responseKey;\n          writeCartKey(responseKey);\n        }\n\n        return data;\n      } catch (error) {\n        const message =\n          typeof (error as { data?: { message?: string } })?.data?.message === \"string\"\n            ? (error as { data?: { message?: string } }).data?.message\n            : error instanceof Error\n              ? error.message\n              : \"Cart request failed\";\n        this.error = message;\n        return null;\n      } finally {\n        this.loading = false;\n      }\n    }\n  }\n});\n"],"names":["_push","_parent","_ssrRenderAttr","_unref","_createVNode"],"mappings":"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","x_google_ignoreList":[0]}